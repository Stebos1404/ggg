<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bounded Coordinate Map</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #0f1115;
    font-family: monospace;
    color: white;
  }

  #coords {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.75);
    padding: 8px 12px;
    border-radius: 6px;
    z-index: 10;
  }

  #export {
    position: fixed;
    top: 10px;
    right: 10px;
    background: #222;
    border: none;
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    z-index: 10;
  }

  canvas {
    display: block;
  }
</style>
</head>
<body>

<div id="coords">X: 0 | Y: 0</div>
<button id="export">Export Pins</button>
<canvas id="canvas"></canvas>

<script>
/* =========================
   Canvas
========================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const coords = document.getElementById("coords");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

/* =========================
   Map size (CENTER ORIGIN)
========================= */
const MAP_HALF_WIDTH = 12288;
const MAP_HALF_HEIGHT = 6144;

/* =========================
   Camera
========================= */
let scale = 0.05;
let offsetX = canvas.width / 2;
let offsetY = canvas.height / 2;

let isPanning = false;
let lastX = 0;
let lastY = 0;

/* =========================
   Pins
========================= */
const pins = [];

/* =========================
   Image loading (CRITICAL)
========================= */
const mapImage = new Image();
let imageLoaded = false;

mapImage.onload = () => {
  imageLoaded = true;
};

mapImage.src = "map.png"; // MUST be same folder

/* =========================
   Coordinate transforms
========================= */
function worldToScreen(x, y) {
  return {
    x: offsetX + x * scale,
    y: offsetY - y * scale
  };
}

function screenToWorld(x, y) {
  return {
    x: (x - offsetX) / scale,
    y: (offsetY - y) / scale
  };
}

/* =========================
   Clamp camera to map
========================= */
function clampCamera() {
  const left   = worldToScreen(-MAP_HALF_WIDTH, 0).x;
  const right  = worldToScreen( MAP_HALF_WIDTH, 0).x;
  const top    = worldToScreen(0,  MAP_HALF_HEIGHT).y;
  const bottom = worldToScreen(0, -MAP_HALF_HEIGHT).y;

  if (left > 0) offsetX -= left;
  if (right < canvas.width) offsetX += canvas.width - right;
  if (top > 0) offsetY -= top;
  if (bottom < canvas.height) offsetY += canvas.height - bottom;
}

/* =========================
   Minimum zoom (NO ESCAPE)
========================= */
function minScaleToFit() {
  return Math.max(
    canvas.width  / (MAP_HALF_WIDTH * 2),
    canvas.height / (MAP_HALF_HEIGHT * 2)
  );
}

/* =========================
   Drawing
========================= */
function drawMapImage() {
  if (!imageLoaded) return;

  const tl = worldToScreen(-MAP_HALF_WIDTH,  MAP_HALF_HEIGHT);
  const br = worldToScreen( MAP_HALF_WIDTH, -MAP_HALF_HEIGHT);

  ctx.drawImage(
    mapImage,
    tl.x,
    tl.y,
    br.x - tl.x,
    br.y - tl.y
  );
}

function drawGrid() {
  const step = 1024;
  ctx.strokeStyle = "#222";
  ctx.lineWidth = 1;

  for (let x = -MAP_HALF_WIDTH; x <= MAP_HALF_WIDTH; x += step) {
    const sx = worldToScreen(x, 0).x;
    ctx.beginPath();
    ctx.moveTo(sx, 0);
    ctx.lineTo(sx, canvas.height);
    ctx.stroke();
  }

  for (let y = -MAP_HALF_HEIGHT; y <= MAP_HALF_HEIGHT; y += step) {
    const sy = worldToScreen(0, y).y;
    ctx.beginPath();
    ctx.moveTo(0, sy);
    ctx.lineTo(canvas.width, sy);
    ctx.stroke();
  }
}

function drawAxes() {
  ctx.strokeStyle = "#555";
  ctx.lineWidth = 2;

  const center = worldToScreen(0, 0);

  ctx.beginPath();
  ctx.moveTo(0, center.y);
  ctx.lineTo(canvas.width, center.y);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(center.x, 0);
  ctx.lineTo(center.x, canvas.height);
  ctx.stroke();
}

function drawPins() {
  ctx.fillStyle = "red";
  pins.forEach(p => {
    const s = worldToScreen(p.x, p.y);
    ctx.beginPath();
    ctx.arc(s.x, s.y, 5, 0, Math.PI * 2);
    ctx.fill();
  });
}

function removeNearestPin(worldX, worldY) {
  const REMOVE_RADIUS = 200; // world units

  let closestIndex = -1;
  let closestDist = Infinity;

  pins.forEach((p, i) => {
    const dx = p.x - worldX;
    const dy = p.y - worldY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < closestDist) {
      closestDist = dist;
      closestIndex = i;
    }
  });

  if (closestDist <= REMOVE_RADIUS && closestIndex !== -1) {
    pins.splice(closestIndex, 1);
  }
}


function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawMapImage();
  drawGrid();
  drawAxes();
  drawPins();
  ctx.setTransform(1, 0, 0, 1, 0, 0); // Opera GX repaint fix
  requestAnimationFrame(render);
}

/* =========================
   Mouse events
========================= */
canvas.addEventListener("mousemove", e => {
  const w = screenToWorld(e.clientX, e.clientY);
  coords.textContent = `X: ${Math.round(w.x)} | Y: ${Math.round(w.y)}`;

  if (isPanning) {
    offsetX += e.clientX - lastX;
    offsetY += e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;
    clampCamera();
  }
});

canvas.addEventListener("mousedown", e => {
  if (e.button === 1 || e.button === 2) {
    isPanning = true;
    lastX = e.clientX;
    lastY = e.clientY;
  }
});

canvas.addEventListener("mouseup", () => isPanning = false);
canvas.addEventListener("mouseleave", () => isPanning = false);

canvas.addEventListener("click", e => {
  const w = screenToWorld(e.clientX, e.clientY);
  if (
    w.x >= -MAP_HALF_WIDTH && w.x <= MAP_HALF_WIDTH &&
    w.y >= -MAP_HALF_HEIGHT && w.y <= MAP_HALF_HEIGHT
  ) {
    pins.push({ x: Math.round(w.x), y: Math.round(w.y) });
  }
});

canvas.addEventListener("contextmenu", e => {
  e.preventDefault(); // stop browser menu

  const world = screenToWorld(e.clientX, e.clientY);
  removeNearestPin(world.x, world.y);
});


/* =========================
   Cursor-centered zoom
========================= */
canvas.addEventListener("wheel", e => {
  e.preventDefault();

  const before = screenToWorld(e.clientX, e.clientY);
  const factor = e.deltaY < 0 ? 1.15 : 0.87;

  scale *= factor;
  scale = Math.min(Math.max(scale, minScaleToFit()), 5);

  const after = screenToWorld(e.clientX, e.clientY);

  offsetX += (after.x - before.x) * scale;
  offsetY -= (after.y - before.y) * scale;

  clampCamera();
}, { passive: false });

/* =========================
   Export pins
========================= */
document.getElementById("export").addEventListener("click", () => {
  const text = pins
    .map((p, i) => `Pin ${i + 1}: X=${p.x}, Y=${p.y}`)
    .join("\n");

  navigator.clipboard.writeText(text);
  alert("Pins copied to clipboard");
});

/* =========================
   Resize
========================= */
window.addEventListener("resize", () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  scale = Math.max(scale, minScaleToFit());
  clampCamera();
});

render();
</script>

</body>
</html>
